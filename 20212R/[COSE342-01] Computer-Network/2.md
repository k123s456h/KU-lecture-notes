## [목차로](./readme.md)

# IPv4
1. 단어의 정확한 정의가 무엇인가
2. 해당 프로토콜, 기술이 나온 이유가 무엇인가 (Motivation)
3. 해당 프로토콜, 기술이 어떻게 작동하는가

# IPv4 Address
인터넷에서 사용하는 디바이스를 전 세계적으로 unique하게 식별하기 위한 것

32비트 (= 8바이트 = 4옥텟octet) 길이임

## classful IPv4 Address
ip주소를 network(locator) 와 host(identifier) 부분으로 나눔. 계층화해서 관리, 라우팅하기 좋음.

```
IP 주소 192.168.0.1
서브넷 마스크: 255.255.255.0

IP주소 AND 서브넷 마스크 = 서브넷 네트워크: 192.168.0.0 
```


### A클래스
1바이트 네트워크 식별, 3바이트 호스트 식별

0.....

### B클래스
2바이트 네트워크, 2바이트 호스트

한 네트워크(조직) 안에서 호스트에게 2^16개의 할당할 수 있는 주소가 있는건데 너무 `많음`.

10......

### C클래스
3바이트 네트워크, 1바이스 호스트

한 네트워크 내에서 호스트에게 2^8개의 할당할 수 있는 주소가 있는건데 `적은` 경우가 생김

110......

### D클래스
전체 멀티캐스트

11110.....

### E클래스
reserved.

11111....

### 문제
B 클래스하고 C 클래스에서 호스트에게 할당하는 주소가 많거나 적어서 문제.

`IP 주소 공간을 비효율 적으로 사용해서`

그래서 classless(CIDR) + subnetting + supernetting이 나옴.


## Special address

host부분이 0인 것은 네트워크 주소를 나타내고, 1인 것은 broadcast 주소를 나타냄.


0.0.0.0 또는 0.(host network) : DHCP 보낼 때(주소할당을 위해), srcIP를 이걸로 함. 그러니까 아직 내 아이피 모르는데 패킷 보낼 떄

255.255.255.255: broadcast: 자기가 속한 subnet에 있는 모든 host에 보냄

{network}||이외의 부분은 다 1: IP directed broadcast: 지정한 네트워크에 있는 모든 host에 보냄. 예시) 211.45.71.255

해당 네트워크가 연결된 스위치까지는 unicast로 가고, 그 스위치에서는 서브넷에 broadcast함.



127.0.0.1: loopback

10.x.x.x, 172.16.x.x, 192.168.x.x : 사설망



## unicast
1:1

MAC주소 기반으로 상대 IP로 일대일통신. 네트워크 내의 다른 CPU 성능 저하시키지 않음.

## broadcast
1:N(all)

패킷 오면 무조건 다 전달. 구성요소 성능 저하시킬 때가 있겠지


## multicast
1:N(not all)



# classless(CIDR) addressing
얘는 클래스 없고 서브넷을 표현할 때 그냥 ip주소 뒤에 /{subnet mast 1 bit 수. 0~32}를 적음.

왜 나왔냐? 클래스 기반 주소 할당이 구려서
- IP주소 할당이 비효율적
- 라우팅 테이블이 확장을 못하겠어

ex) 기본의 B 클래스의 ip주소가 172.16.0.0이면 network mask(서브넷 마스크) = 255.255.0.0인데 CIDR로 표현하면 172.16.0.0/16

192.168.0.2/24 면, 서브넷 마스크 = 255.255.255.0임. 클래스로 표현하면 C클래스

```
기존 class addressing의 구조가 이랬는데
|network prefix | host number |
ip주소가 이렇게 구성된대
|network prefix | subnet number | host number |
```

```
IP주소 192.168.0.1/24
서브넷 네트워크 = IP주소 AND {앞 24비트 1, 나머지 0} = 192.168.0.0
```

## subnetting
B클래스를 C클래스로 유연하게 할당하기 위함.

x.x.x.x/22하면은 이거는 x.x.x.x/16(B클래스) 내에서 또 조직을 나눈 것임

예제) 211.100.10.0/24인 네트워크에서 한 네트워크에 60개의 host가 할당되도록 subnetting해라
```
60개면 최소한 2^6=64 개의 호스트가 필요할 것임.

일단 /24니까 사용할 수 있는 비트는 8개고, 이 중에서 6개를 호스트 할당에 사용하면
2개를 subnet에 사용할 수 있다.

따라서 
subnet mask: 211.100.10.0/26
subnet 개수: 2^2 = 4
각 subnet에서 사용가능한 호스트 수: 첫번째 subnet을 생각해보면
211.100.10.1 ~ 211.100.10.62 : 62개가 가능함. 
맨 처음(10.0)과 맨 마지막(10.63)은 host 비트가 0000...과 1111...인데 이거는 예약된 거라고 했음.
그러면 총 62*4개

마지막 subnet에서 representative address? : representative address는 host가 0000..인거
그러면 0~63, 64~127, 128~191, 192~255 범위니까, 211.100.10.192 


```

## supernetting
C클래스에서 B클래스로 합치기 위함.

C클래스에서 호스트들을 합치기 위함임.

표기: (first class C network address, count)

예시: (192.5.48.0, 3)이라 하면 192.5.48.0, 192.5.49.0, 192.5.50.0을 나타냄

```
162.158.32.0/22였던 원래 네트워크를 4개로 나누고 싶다.
4개니까 2비트를 서브네트워크로 할당하면
각각 서브넷은

162.158.32.0/24   // 00
162.158.33.0/24   // 01
162.158.34.0/24   // 10
162.158.35.0/24   // 11
이 될 것이고

서브넷 마스크는 24니까 255.255.255.0이다.
```




# IP통신을 하는데 필요한 4가지
1. IP주소 
> 내 id
2. 서브넷 마스크
> 내 네트워크가 어떻게 되는지. 예시) 255.255.255.0
3. 기본 게이트웨이
> 가장 처음으로 만날 라우터 주소
4. DNS서버
> url -> ip로 바꿔주는 얘







## [목차로](./readme.md)