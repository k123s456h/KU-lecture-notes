## [목차로](./readme.md)

# ch1
1.3. 수학 문제는 수식 입력하기 귀찮으니 생략

답:

1: 5, 2:16, 3: 10

1.5. Shift Cipher가 Perfect Secrecy 만족함을 보여라

구글링하면 `P(P=p|C=c)=P(P=p)` 이거 보이라 나오는데 왜 교재는 포함관계임? 몰루

p와 c 각각이 26자 중에 하나이므로 일단 P(P=p)와 P(C=c)는 각각 1/26임.

bayes rule에 따라서 `P(P=p|C=c) = P(P=p AND C=c)/P(C=c)`임.

`P(P=p AND C=c)`는 (p, c)쌍으로 생각할 수 있고 그러면 확률은 (1/26)^2임.

따라서 두 값은 1/26으로 같음.


1.16. Vigenere Cipher의 분석 기법 중 하나인 **Kaisiski** 방법에 대해 설명하시오

답: 비제네르 암호(Vigenere Cipher)는 다중문자 치환 암호이다.

특정 문자열을 키로 사용함. `K = k1k2k3...kd, f_i(m) = (m + k_i) mod n`

Kasiski 방법은 암호화 키의 길이를 찾는 방법이다. 이 방법을 사용하는 원리는, `키 길이의 배수`만큼 떨어져 있는 `같은 평문`은 `같은 암호문`으로 암호화 된다는 것이다. 암호문에서 반복되는 문자열을 찾아서 떨어진 거리를 각각 계산한 후, 모든 거리의 최대 공약수가 암호키의 길이가 된다.


# ch2

2.5. Feistel 암호가 비가역 구성요소를 사용해도 복호화가 가능한 이유

답: 복호화과정에서 배타적논리합(XOR) 연산의 성질에 의하여 라운드함수(F)가 상쇄되므로 비가역 구성요소를 사용해도 복호화에는 문제가 없다.

2.17. 56비트의 키 길이를 사용하는 DES 암호 암호화를 Ek(p)라고 했을 때, 이를 변형하여 112비트의 키를 사용하는 암호 알고리즘을 다음과 같이 설계하였다. 다음 알고리즘의 안전성에 대해 논하시오.

Dk2(Ek1(p)) = c, k1과 k2는 56비트

답: double des의 문제점하고 비슷한 것이라 생각함. 중간일치 공격을 수행하면 총 키 길이는 112비트 임에도 공격에는 그보다 훨씬 적은 2^57정도의 연산밖에 걸리지 않음. 또 다른거 있나?


2.23. DSE의 짧은 키를 극복하기 위해 삼중 DES가 소개되었다. 하지만 DES의 암/복호화를 세번 수행하야 하기 때문에 속도가 느려지게 된다. 이를 극복하기 위하여 다음과 같은 방법을 고려해보자. k는 56비트 DES 키이고 k1과 k2는 64비트 난수이다.

암호화: c = E_k,k1,k2(p) = E_k(p XOR k1) XOR k2

복호화: p = D_k,k1,k2(c) = D_k(c XOR k2) XOR k1

3개의 키 k,k1,k2가 사용되었지만 한번의 DES암호화만 수행하기 때문에 삼중 DES보다 효율적이다. 전사적으로 키를 모두 찾는 경우 2^(56+64+64)의 연산이 필요하다. 만약 중간 일치 공격을 수행하면 키를 찾기 위해 얼마의 계산량이 필요한지 계산해보시오

답: 2^(54+64)보다 작은 연산량이 필요할 것이다.

참고로 이 알고리즘을 [DES-X](https://en.wikipedia.org/wiki/DES-X)라고 함

2.3.

이거는 주어진 그림에 점찍어가면서 풀면 됨. 

표 읽는 법은 n번째 비트가 입력되었을 때 영향을 받는 모든 비트를 적어놓은 것임.

# ch3
3.11. AES는 복호화 시 DES와는 다르게 암호화 시에 사용했던 구조를 그대로 사용하지 못하고 각각의 구성요소의 역을 사용하여 복호화한다. 이유를 설명하시오.

답: 비페이스텔구조이고 'XOR연산으로 각 라우드 함수가 상쇄되지 않기 때문'(이거 맞나?)

3.13. AES의 1라운드는 SubBytes -> ShiftRows -> MixColumns -> AddRoundKey순으로 구성된다. 이 때 구성요소간 순서 변경이 가능한 곳이 있는지 답하고 있다면 그 이유를 설명하시오.

답: ShiftRows와 SubBytes의 순서를 바꿀 수 있다. SubBytes가 state의 한 바이트을 개별적으로 바꾸는 연산이고, ShiftRows는 순서만 변경할 뿐 각 바이트의 값을 변경시키지 않기 때문이다.

# ch4
4.4. 평문 m에 대하여 CBC모드를 이용하여 암호문 c를 얻었다.
c를 전송하는 과정에서 암호문의 2번째 블록인 c2에 1비트 오류가 발생하였다. 이를 수신한 수신자는 암호문 c를 복호화하여 평문 m\`을 얻었다고 할 때, m\`과 m은 어느정도의 차이가 발생하는지 설명하시오.

답: CBC에서의 복호화 과정은 다음과 같다.
현재 블록의 암호문이 그대로 복호화 함수를 통해 나온 값과 이전 블록의 암호문이 XOR되어 현재 블록의 평문이 만들어진다.

따라서 c2에 1비트 오류가 발생하였다면, 2번째 블록에서의 복호화 함수에서 나온 값은 완전히 다른 값이 될 것이고 따라서 m2는 복구가 불가능 하다. 그리고 c2가 m3의 복호화 과정 중 XOR을 해서 영향을 주기 때문에 m3에서는 1비트 오류가 발생하게 된다.

4.5. 평문 M에 대하여 CBC모드를 이용하여 암호문 C를 얻는다.
5,6번째 평문과 암호문 쌍이 다음과 같을 때,
```
m5=11110000, m6=01011111
c5=01011111, c6=01010101
```
5번째 암호문이 전송 도중 채널오류로 인해 `c'5=11111010`으로 변경되었다. 이 때 수신자가 c6을 복호화 할 경우에 얻게 되는 m'6을 구하시오.

답: 우선 복호화 함수를 거친 직후의 값(D(c6))를 구해야 한다.

6번째 블록이 제대로 복호화가 된다고 가정하면
```
m6 = D(c6) XOR c5
01011111 = D(c6) ^ 01011111
따라서 D(c6) = 00000000
```
여기서 오류가 발생한 c5로 교체하면, m'6은 11111010가 된다.



4.6. CFB 모드를 이용해 한 번에 한 바이트씩 암호화하는 DES를 가정하자. 만약 한 바이트의 암호문을 전송중에 한 비트에 오류가 발생했다면, 이 오류는 복호화 과정에서 얼마나 많이 확산되느지 설명하시오.

답: DES는 64비트의 블록 크기를 가지고 있으므로 n=64이다. 문제에서 CFB모드를 통해 한 바이트씩 암호화하므로 r=8이다. 

k번째 암호문에서 한 비트에 오류가 발생했다면, k번째 평문에서는 한 비트에만 오류가 발생한다. 그리고 CFB의 특성에 의해서 오류가 확산하는데  k+1번째 부터 K+n/r번째 까지의 평문은 복호화함수에 정상적인 입력이 들어오지 않으므로 복호화가 불가능하다.

따라서 이 문제에서는 k번째 암호문은 한 비트를 제외하면 복구가 가능하지만, k+1번째부터 k+8번째 암호문은 복구가 불가능하다. 이외의 암호문은 복호화가 정상적으로 가능하다.



4.7. CFB, OFB, CTR모드에서는 암호문 스틸링 기법(CTS)이 필요없는 이유를 설명하시오

답: ECB나 CBC는 블록 단위로 암호화를 진행한다. 따라서 블록 사이즈에 딱 맞는 평문이 아니면 블록 크기에 맞춰서 패딩을 적용하는 것이다. CTS는 이 패딩 과정을 생략하도록 하는 기법이다. 하지만 CFB, OFB, CTR모드는 비트 단위로 진행되는 스트림 암호를 만들기 위해서 사용되는 것이고, 블록 단위보다 작은 단위로 암호화를 진행할 수 있다. 따라서 굳이 패딩과 관련된 작업을 할 필요가 없고 마찬가지로 CTS도 필요가 없다.


# ch6

6.1. 대칭키 암호시스템과 공개키 암호시스템의 차이점을 설명하시오

답:
```
                   대칭키     공개키
비밀키 분배           필요     불필요
보유 `비밀키` 개수    n-1개     1개
                  상대방별로   자신 것만
암/복호화 속도        빠름      느림
```


참고: 대칭키 암호 시스템은 수신자와 송신자가 대칭키를 공유한다. 그러므로 안전한 채널을 통해서 키를 공유해야할 필요성이 생긴다. 그리고 사용자가 많아질수록 공유해야하는 대칭키의 수도 급격하게 증가한다. 따라서 대칭키 암호 시스템은 비밀키를 생성하고 분배, 관리하는 문제점이 있다. 또한 송신자와 수신자가 공유하는 키가 같기 때문에 누가 암호문을 생성했는지 판단할 수없다. 즉 부인방지 기능이 없다.
```
1. 안전한 채널로 사전에 동일한 키를 공유해야한다.
2. n명이 비밀통신하려면 n(n-1)/2개의 키의 생성과 공유가 필요하다.
3. 부인 방지 기능이 없다.
```

반면에 공개키 암호 시스템은 각 사람마다 공개키와 개인키로 이루어진 한 쌍의 키를 가진다. 공개키는 모두에게 공개되고 개인키는 자신만이 알도록 비밀로 보관된다. 송신자가 메시지를 보낼때는 수신자의 공개키로 암호화하여 보내고 수신자는 자신의 개인키로 복호화한다. 사전에 키를 공유할 필요가 없다.


6.2. 일방향 함수와 트랩도어 일방향 함수를 각각 설명하고, 다음과 같은 함수 f(x)가 일방향 함수가 되지 않는 이유를 설명하시오

`f(x) = x^2 + 5x + 6`

답: 일방향 함수는 메시지 m에 대하여 `c = f(m)`의 계산은 쉬운데, c만 주어진 경우 역함수의 계산 즉 `m = f^-1(c)`를 구하기 어려운 함수 `f`를 말한다.

트랩도어 일방향 함수는 일방향 함수와 성질은 비슷하지만, c만 주어질 때 어떤 정보 `k`가 주어지면 쉽게 역함수를 계산하여 m을 얻을 수 있을 때, 이 함수 `f`를 말한다.

이차함수의 경우에는 근의공식이 있기 때문에 함수값만 주어졌을 때도 그 식이 성립하는 x값을 쉽게 찾아낼 수 있기 때문에 일방향 함수가 되지 않는다.



6.10. 제곱-곱 연산 방법을 이용하여 지수승 연산을 수행하는 경우, 지수의 절대적인 크기보다는 지수를 2진수로 표현하였을 때 Hamming weight가 얼마냐에 따라 수행속도가 결정된다. 그 이유를 설명하시오.

Hamming weight: 어떤 스트링에서 0이 아닌 symbol의 개수. 110011에 대한 hamming weight는 4

답: 지수를 2진수(비트)로 표현했을 때 (비트길이-1)만큼의 제곱 연산과 (hamming weight(비트 1의 개수) - 1)만큼의 곱 연산이 필요하다. 따라서 hamming weight가 작아야 곱셈 연산이 줄어들기 때문이다.

6.11, 첨부문서 참고

6.12, 첨부문서 참고



# ch8

8.1. 한 학급에 40명의 학생이 있다. 이 때, 다음 사건의 확률을 계산하시오

1. 해당 학급에서 어떤 학생 A와 같은 생일인 학생이 적어도 한 명 이상 있을 경우 (제2역상저항성)

2. 해당 학급에서 어떤 학생 A와 같은 생일인 학생이 정확하게 한 명 있는 경우 (제2역상저항성)

3. 해당 학급에서 생일이 같은 경우가 적어도 하나 이상 있는 경우 (충돌저항성)

답:
1. `1 - Pr(A와 같은 생일인 학생이 없는 경우)`

= `1 - 365/365 * (364/365)^(40-1)` 

// A는 하나 골라놓고 나머지 39명끼리 생일 알아서 골라. 그러면 A하고 같은 생일인 사람은 없을 것임.

= `1 - (364/365)^39`

= 0.1014

2. `1/39 * (364/365)^38`

= 0.023


3. `1 - Pr(모든 학생의 생일이 겹치지 않는 경우)`

= `1 - 365/365 * 364/365 * 363/365 * ... * 326/365`

= `1 - (1 - 1/365) * (1 - 2/365) * (1 - 3/365) * ... * (1 - (40-1)/365)`

= 0.8912

(아 근데 솔직히 자신 없다)



8.2. 인원수가 k명인 단체 A가 있고, 인원 수가 l명인 단체 B가 있다. 두 그룹에서 생일이 같은 사람이 적어도 한 쌍이 나올 확률은 얼마나 되는가?

생일문제 4번째 유형임dn

답: `1 - Pr(두 그룹에서 생일이 다른 경우)`

`Pr(두 그룹에서 생일이 다른 경우)`

= `각 그룹 내에서는 얼마나 겹치든 상관 없고, A그룹과 B그룹에 할당되는 생일 값만 다르면 됨`

= `(365일을 (1, 1)으로 분할 하는 것부터 (k, l)으로 분할하기, 각 분할에 Product (365-k) k=0...(k+l-1) 적용) * (1/365)^(k+l)`

= `(1/365)^(k+l) * Sigma_i=1..k Sigma_j=1..l S(k, i)S(l, j) Product_k=0..(i+j-1) (365 - k)`

답 = `1 - {(1/365)^(k+l) * Sigma_i=1..k Sigma_j=1..l S(k, i)S(l, j) Product_k=0..(i+j-1) (365 - k)}`

단 S(n, k)는 집합의 분할임.

`S(n, k) = S(n-1, k-1) + k * S(n-1, k)`

`S(n, n) = 1, S(n, 1) = 1, S(n, n-1) = nC2, S(n, 2) = 2^(n-1) - 1`

근데 이 경우는 A내에서 또는 B내에서 겹치는 경우 생각 안했음

[위키피디아](https://en.wikipedia.org/wiki/Birthday_problem#Generalization_to_multiple_types_of_people) 이 유형같은데...




8.3. 암호학적 해쉬함수의 3가지 안전성

역상 저항성: given h, infeasible to find `x` s.t. H(x)=h

제2역상 저항성: given x, infeasible to find `y` s.t. H(y)=H(x)

충돌 저항성: infeasible to find any `(x, y)` s.t. H(y)=H(x)


8.4. MDC를 사용할 경우 메시지의 해쉬 값은 안전한 채널을 통해서 전달해야 한다. 이 이유를 설명하고 안전한 채널을 사용하지 않고 전송 가능한 방법이 있다면 설명하시오.

답: MDC는 메시지가 변조되었는가를 확인하기 위해서 수신자 측에서 받은 메시지를 이용해서 해쉬함수를 거쳐 나온 h'(m)과 수신받은 h(m)을 비교한다. 따라서 변조감지코드 h(m)이 안전한 채널로 전송되야 신뢰성 있는 변조확인을 할 수 있다.

안전한 채널을 사용하지 않고 전송하려면 MDC 대신에 MAC를 사용할 수 있다. 이 경우는 메시지 인증 키를 사전에 공유함으로써 메시지의 무결성을 검증할 수 있다. 키를 미리 공유하고 있으므로 안전한 채널을 사용하지 않고 해쉬 값을 전송할 수 있다.


8.5. MDC를 설계할 때, 해쉬를 두 번 사용할 경우 한 번 사용하는 것보다 안전한지 서술하시오. h(m) vs h(h(m))

답: 

해쉬를 한번 사용했을 때 한번 사용한 해쉬가 공격가능하다고 하면
```
1. 역상저항성) given h, infeasible to find x s.t. H(x) = h.
그러면 해쉬를 두번 사용한 해쉬값에서 h(h(x))인 h(x)을 찾을 수 있다는 뜻이고 같은 식으로
x을 찾을 수 있다.

2. 제2역상저항성) given x, infeasible to find y s.t. H(y) = H(x)
x가 주어졌을 때 h(x)=h(y)인 y를 찾았다고 하면 이것은 h(h(x))=h(h(y))를 내포한다.

3. 충돌저항성) infeasible to find any (x, y) s.t. H(y) = H(x)
h(y)=h(x)인 임의의 (x, y)를 찾았다고 가정하면,
마찬가지로 이것은 h(h(x))=h(h(y))를 내포한다.
```
따라서 해쉬를 한번 사용한 경우가 공격 가능하면 마찬가지로 두번 사용한 경우도 공격 가능하므로 안전도는 그대로이다.


8.6. MDC와 MAC의 차이점을 서술하시오.

답:
```
                    MDC   MAC
사전 키 공유          X     O
안전한 채널 사용      O     X
메시지의 무결성       O     O
데이터 출원 인증      X     O
부인 방지            X      X
```


8.7. CBC-MAC를 이용하여 메시지 인증 코드를 생성시, 고정된 길이의 메시지만 사용이 가능하다. 가변 길이의 메시지를 CBC-MAC을 이용하여 메시지 인증 코드를 생성하게 되는 경우 발생하는 문제점을 설명하시오.


답:
공격자가 (메시지, 해쉬 쌍)을 두개 알고 있다고 하고 각각 (M, T), (M', T')이라 하자.
M=m1m2m3...mr, M'=m'1m'2m'3...m'r

만약 CBC-MAC의 입력에 M''= M||m'1 XOR T||m'2m'3...m'r을 넣으면 T'이 나온다.

이것은 (M', T')에 대한 제2역상 M''을 찾은 것으로 CBC-MAC을 안전하게 사용하기 위해서는 항상 고정된 길이의 메시지를 입력값으로 받아들여야 한다.





[참고](./handwriting_mid.pdf)



## [목차로](./readme.md)