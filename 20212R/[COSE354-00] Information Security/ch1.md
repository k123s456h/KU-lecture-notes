## [목차로](./readme.md)

# 암호학

암호학은 보안 시스템의 가장 중요한 부분이지만 다른 시스템의 취약점에 의존
> A security system is only as strong as its weakest link

각 구성요소 모두가 매우 안전해야 한다.


## 암호학(cryptology)
1. 암호기법(cryptography)
> kryptos(secret) + grapho(write)의 합성어
2. 암호해독(cryptanalysis)

## 암호기법(cryptography)
1. 암호시스템(cryptosystem)
2. 암호 프로토콜(cryptographic protocol)

## 암호시스템(cryptosystem)
1. 대칭키 암호(symmetric key cipher)
> Ek(p) = c; Dk(c) = p;<br>
> 어떻게 k를 공유할건데<br>
> 장점: 빠르다;             단점: 키 공유하는게 문제
2. 공개키 암호(asymmetric key cipher)
> Epk(p) = c; Dsk(c) = p;<br>
> 장점: 키 공유 필요가 없음; 단점: 느리다;


## 암호화
구성 요소: (P(plaintext), C(ciphertext), K(key), E(encryption function), D(decryption function))

암호화의 가정: 통신채널은 안전하지 않다.

## Kerckhoff's Principle
암호 알고리즘은 알고리즘의 모든 내용이 공개되어도 키가 노출되지 않으면 안전해야한다.
1. 알고리즘 전체 보관보다 그거보다 짧은 키를 보관하는게 더 쉬움
2. 어차피 암호 시스템은 역공학으로 노출될 수 있음. 알고리즘을 숨기는 상태라면 이런 경우에 새로 알고리즘을 설계해야함.
3. 암호 시스템이 털렸을 때 키를 바꾸는게 알고리즘을 바꾸는 것보다 더 쉬움
4. 암호 시스템을 많은 사용자가 쓰는데 각 사용자마다 다른 알고리즘 쓰는 것보다 같은 알고리즘 쓰고 키만 바꾸는게 실용적(표준화)

# 수학적 배경지식

## 최대공약수(GCD)
- 유클리드 알고리즘

1. `gcd(a, 0) = a`;
2. `gcd(a, b) = gcd(b, r), r=a%b`;

- 확장 유클리드 알고리즘(EEA)

적어도 하나는 0이 아닌 두 정수 a, b에 대해 `s*a + t*b = gcd(a,b)`인 s, t가 존재한다. (증명은 생략한다.)

여기서 `s`하고 `t`를 구하는게 확장 유클리드 알고리즘.

근데 그걸 어디에 쓰냐 => 모듈러 연산할 때 곱셈의 역원을 구하기 위해

### 어떻게 하는건데
```
1.    r1=a, r2=b  ->  r   |   s1=1, s2=0  ->  s   |   t1=0, t2=1  ->  t
      r1에 b를, r2에 r을 대입
2.    r1=b, r2=r  ->  r   |   s1=0, s2=s  ->  s   |   t1=1, t2=t  ->  t
      r이 0이 될때까지 반복
k.    r1=r, r2=0          |   s1=..., s2=..          |   t1=..., t2=..

결과    gcd(a,b) = r            s=s1                     t=t1

다시말하면

r1=a; r2=b;
s1=1; s2=0;
t1=0; t2=1; 
로 초기화하고 위 과정을
r2==0이 될 때까지 반복함.
그 마지막 단계에서의 값들이 정답임
```

## 모듈라 연산(modular arithmetic)
`a = qn + r, 0 <= r < n` 일 때, `a mod n = r`이다.

mod 연산은 완전잉여계 Zn을 만든다. `Zn = {0, 1, 2, ..., (n-1)}`. 덧셈과 곱셈에 대해 닫혀있음.

### 합동(≡)
`mod n`을 취한 값이 같으면 합동이라고 한다.
```
-8 ≡ 2 ≡ 12 (mod 10);  13 ≡ 23 (mod 10);
3 ≡ 8 (mod 5);          8 ≡ 13 (mod 5);
```

### mod 연산의 성질
1. `(a+b) mod n = [(a mod n) + (b mod n)] mod n`
2. `(a-b) mod n = [(a mod n) - (b mod n)] mod n`
3. `(a*b) mod n = [(a mod n) * (b mod n)] mod n`;

-> a^m mod n = (a^m-k mod n) * (a^k mod n) mod n;

예제
```
6371 mod 3 = ?
6371 = 6*10^3 + 3*10^2 + 7*10 + 1*10^0
6371 mod 3
= [6*10^3 mod 3 + 3*10^2 mod 3 + 7*10 mod 3 + 1*10^0 mod 3] mod 3
= [{(6 mod 3 * 10^3 mod 3)mod 3}mod 3+ 3*10^2 mod 3 + 7*10 mod 3 + 1*10^0 mod 3] mod 3
= [0 + 0 + 7*10 mod 3 + 1*10^0 mod 3] mod 3
= [(1 * 1)mod3 + 1 mod 3] mod 3
= 2
```

### mod 연산의 역원 (Inverse)
1. Zn 상에서의 덧셈의 역원
> 항상 존재함

`a + b ≡ 0 (mod n)`이면 b가 a에 대한 덧셈의 역원

2. Zn 상에서의 곱셈의 역원
> `a`와 `n`에 따라서 존재하지 않을 수 있음<br>
> `gcd(n, a) ≡ 1 (mod n)`이면 존재함. 다시말하면 `a와 n이 서로소`

`a * b ≡ 1 (mod n)`이면 b가 a에 대한 곱셈의 역원

곱셈의 역원의 존재조건 증명

```
확장 유클리드 알고리즘(EEA)을 이용한다.

가정) gcd(n, a) ≡ 1 (mod n)

gcd(n, a) = s*n + t*a인 s, t가 존재한다.

양변에 mod n 연산을 취하면

1 ≡ t*a (mod n)이 나옴. 그러면 t가 a에 대한 곱셈의 역원임
```
예제
```
a=2, n=7일 때, a에 대한 곱셈의 역원은?

a와 n이 서로소니까 곱셈의 역원이 존재함.

gcd(n, a) = gcd(7, 2) ≡ 1 (mod 7)가 성립함.
여기서 확장 유클리드 알고리즘(EEA)를 적용하면
gcd(7, 2) = -1 * 7 + 4 * 2;
따라서 a에 대한 곱셈의 역원은 4이다.
```

## 고전암호 
// 공부할때는 이거말고 현대암호에 집중할 것

대칭키 암호임

- 2가지 원칙

1. 치환(substitution): 문자바꾸기
2. 전치(transposition): 문자의 위치 바꾸기

// 암호 단위: 고전 - 문자, 현대 - 비트

- 공격 유형

1. 전사적 공격(Brute Force Attack)
> 고전 암호는 키 길이가 짧아서 다 넣어볼 수 있음
2. 빈도수 분석(Frequency Analysis)
> 평문의 통계학적 특성이 암호문에도 반영된다는 사실 이용

### 치환 암호(Substitution Cipher)
1. 단일 문자 치환 암호(Monoalphabetic Substitution Cipher)
2. 다중 문자 치환 암호(Polyalphabetic Substitution Cipher)
> 단일 문자 치환 암호에서는 평문의 통계학적 특성이 반영되는 문제가 있어서 그걸 줄이기 위한 것

#### 단일 문자 치환 암호(Monoalphabetic Substitution Cipher)
**덧셈 암호 또는 시저 암호(Addictive Cipher, Caesar cipher)**

평문의 한 문자가 오른쪽 k자리 뒤에 위치한 문자로 치환.

알파벳을 암호화 할때

암호화: c ≡ m + k (mod 26), k in Z26

복호화: m ≡ c - k (mod 26), c in Z26

암호키 표(예시는 시저암호. k가 항상 3으로 일정함.)
```
------------------------------
평문   | A B C D E ... X Y Z 
암호문 | C D E F G ... A B C
----------------------------
```

- 가능한 키 개수

알파벳이라 하면 26!의 개수가 필요함.

- 공격법

따라서 전사적 공격(브루트 포스)는 불가능함. 통계적 방식은 가능할 것

#### 다중 문자 치환 암호(Polyalphabetic Substitution Cipher)
**비제네르 암호(Vigenere Cipher)**

길이가 I인 키워드를 암호화 키로 사용함.

`K = k1k2k3...ki, fj(m) = (m + kj) mod n`

예시
```
K = "CIPHER", I=6(주기)

평문    T H I S I S A S E C R E T M E S S A G E
키      C I P H E R C I P H E R C I P H E R C I
암호문  V P X Z M J C A T J V V V U T Z W R I M
```

- 공격법

주기 d를 결정해야 함.

특정한 길이의 문자열이 나오는 위치로 추정. 그리고 빈도수 분석(통계적)



### 전치 암호(Transposition Cipher)
평문 메시지의 문자를 재배열

암호화 함수를 π, 문자열 길이를 l이라 하면

π = (π(1), ..., π(l)),        

π(i): 평문에서 i번째 위치에 있는 문자의 암호문에서의 위치

예시: π=(3, 1, 4, 5, 2) // 이게 비밀키가 됨

```
평문    T H I S I S ...
암호문  H I T I S ....
```

- 공격법

메시지 길이가 30이라고 하면 암호화하는 블록 길이가 30의 약수일 것임

그러면 가능한 키 개수는 `1! + 2! + 3! + 5! + 6! + 10! + 15! + 30!`

// 이렇게 해석하는게 맞는건가?

## 암호 시스템의 안전성

- 공격 유형

1. 수동적 공격(Passive Attack)
> 도청, 트래픽 분석, ...
2. 능동적 공격(Active Attack)
> 메시지 변조, 메시지 삭제, 위장공격, 재전송 공격, ...

- 공격 모델(Attack Model)

1. 암호문 단독 공격(COA)
> 암호문 하나 빼와서 분석하는 것임<br>
> 가장 흔한 케이스
2. 알려진 평문 공격(KPA) or 기지 평문 공격
> (평문, 암호문)쌍을 알아내서 새로운 암호문을 해독
3. 선택 평문 공격(CPA)
> 공격자가 선택한 평문에 대한 암호문을 얻을 수 있음. 그것을 새 암호문 분석에 활용 <br>
> 송신자를 속일 수 있어야겠네
4. 선택 암호문 공격(CCA)
> 공격자가 선택한 암호문에 대한 평문을 얻을 수 있음. 그것을 새 암호문 분석에 활용<br>
> 수신자를 속일 수 있어야겠네

- 안전성 개념

암호문이 주어졌을 때,
1. 키를 찾을수 없어야 한다
2. 평문을 찾을 수 없어야 한다
3. 어느 문자도 찾을 수 없어야 한다 (No adversary can find any character)
4. 어느 의미있는 정보도 찾을 수 없어야 한다.
5. 암호문으로부터 평문에 대한 어느 함수도 계산할 수 없어야 한다.

## 정보보호 서비스
1. 기밀성
> 대칭키, 공개키 암호시스템이 제공함
2. 무결성
> 데이터가 변하지 않음을 검증 <br>
> [해쉬함수](./ch8.md)가 제공함
3. 가용성
> 정당한 사용자가 원할 때에 사용할 수 있음.

추가적으로
- 인증
> 개체가 정당한 개체인가<br>
> 메시지가 정당한 송신자로부터 보내졌는가
- 부인 방지
> A가 메시지를 보냈는데 안보냈다고 우기는거
- 접근 제어

## [목차로](./readme.md)